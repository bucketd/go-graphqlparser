package main

import (
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

var (
	packageName string
	typeNames   string
)

var header = `
// Code generated by lab/generics
// DO NOT EDIT!
`

func main() {
	flag.StringVar(&packageName, "package", "", "The package name to use in the generated code.")
	flag.StringVar(&typeNames, "types", "", "Comma separated names of types to generate.")
	flag.Parse()

	fmt.Fprintf(os.Stdout, strings.TrimSpace(header))
	fmt.Fprintf(os.Stdout, "\npackage %s\n", packageName)

	tns := strings.Split(typeNames, ",")

	sort.Strings(tns)

	for _, tn := range tns {
		typeNameLCF := lcfirst(tn)
		if typeNameLCF == "type" {
			typeNameLCF = "t"
		}
		if typeNameLCF == "error" {
			typeNameLCF = "err"
		}

		linkedList.Execute(os.Stdout, map[string]string{
			"TypeNameLCF": typeNameLCF,
			"TypeName":    tn,
			"AbridgedTN":  strings.Map(abridger, tn),
		})
	}
}

// Add
// ForEach
// Insert
// Join
// Len
// Reverse
// ArgumentsFromSlice // not method

var linkedList = template.Must(template.New("linkedList").Parse(`
// {{.TypeName}}s is a linked list that contains {{.TypeName}} values.
type {{.TypeName}}s struct {
	Data {{.TypeName}}
	next *{{.TypeName}}s
	pos  int
}

// Add appends a {{.TypeName}} to this linked list and returns this new head.
func ({{.AbridgedTN}} *{{.TypeName}}s) Add(data {{.TypeName}}) *{{.TypeName}}s {
	var pos int

	if {{.AbridgedTN}} != nil {
		pos = {{.AbridgedTN}}.pos + 1
	}

	return &{{.TypeName}}s{
		Data: data,
		next: {{.AbridgedTN}},
		pos: pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func ({{.AbridgedTN}} *{{.TypeName}}s) ForEach(fn func({{.TypeNameLCF}} {{.TypeName}}, i int)) {
	if {{.AbridgedTN}} == nil {
		return
	}

	iter := 0
	current := {{.AbridgedTN}}

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the {{.TypeName}} in the position given.
func ({{.AbridgedTN}} *{{.TypeName}}s) Insert(item {{.TypeName}}, pos int) {}

// Join attaches the tail of the receiver list "{{.AbridgedTN}}" to the head of the otherList.
func ({{.AbridgedTN}} *{{.TypeName}}s) Join(otherList *{{.TypeName}}s) {
	pos := {{.AbridgedTN}}.Len() + otherList.Len() - 1

	last := {{.AbridgedTN}}
	for {{.AbridgedTN}} != nil {
		{{.AbridgedTN}}.pos = pos
		pos--
		last = {{.AbridgedTN}}
		{{.AbridgedTN}} = {{.AbridgedTN}}.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func ({{.AbridgedTN}} *{{.TypeName}}s) Len() int {
	if {{.AbridgedTN}} == nil {
		return 0
	}
	return {{.AbridgedTN}}.pos + 1
}

// Reverse reverses this linked list of {{.TypeName}}. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func ({{.AbridgedTN}} *{{.TypeName}}s) Reverse() *{{.TypeName}}s {
	current := {{.AbridgedTN}}

	var prev *{{.TypeName}}s
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// {{.TypeName}}sFromSlice returns a {{.TypeName}}s list from a slice of {{.TypeName}}.
func {{.TypeName}}sFromSlice(sl []{{.TypeName}}) *{{.TypeName}}s {
	var list *{{.TypeName}}s
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}
`))

func lcfirst(in string) string {
	if len(in) == 0 {
		return in
	}

	if len(in) == 1 {
		return strings.ToLower(in)
	}

	fr, w := utf8.DecodeRuneInString(in)

	return strings.ToLower(string(fr)) + in[w:]
}

func abridger(r rune) rune {
	if unicode.IsUpper(r) {
		return unicode.ToLower(r)
	}
	return -1
}
