package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

type typeInfo struct {
	realTypeName string
	isPointer    bool
}

var (
	packageName string

	ti = map[string]typeInfo{
		"Arguments":                   {"ast.Arguments", true},
		"ArgumentsDefinition":         {"ast.InputValueDefinitions", true},
		"Definitions":                 {"ast.Definitions", true},
		"DirectiveDefinition":         {"ast.DirectiveDefinition", true},
		"DirectiveLocations":          {"ast.DirectiveLocations", true},
		"Directives":                  {"ast.Directives", true},
		"EnumTypeExtension":           {"ast.TypeExtension", true},
		"EnumValuesDefinition":        {"ast.EnumValueDefinitions", true},
		"ExecutableDefinition":        {"ast.ExecutableDefinition", true},
		"FieldsDefinition":            {"ast.FieldDefinitions", true},
		"FragmentDefinition":          {"ast.ExecutableDefinition", true},
		"ImplementsInterfaces":        {"ast.Types", true},
		"InputFieldsDefinition":       {"ast.InputValueDefinitions", true},
		"InputObjectTypeExtension":    {"ast.TypeExtension", true},
		"InterfaceTypeExtension":      {"ast.TypeExtension", true},
		"ObjectTypeExtension":         {"ast.TypeExtension", true},
		"OperationDefinition":         {"ast.ExecutableDefinition", true},
		"ScalarTypeExtension":         {"ast.TypeExtension", true},
		"SchemaDefinition":            {"ast.SchemaDefinition", true},
		"SchemaExtension":             {"ast.SchemaExtension", true},
		"Selections":                  {"ast.Selections", true},
		"TypeDefinition":              {"ast.TypeDefinition", true},
		"TypeDefinitionEnum":          {"ast.TypeDefinition", true},
		"TypeDefinitionInputObject":   {"ast.TypeDefinition", true},
		"TypeDefinitionInterface":     {"ast.TypeDefinition", true},
		"TypeDefinitionObject":        {"ast.TypeDefinition", true},
		"TypeDefinitionScalar":        {"ast.TypeDefinition", true},
		"TypeDefinitionUnion":         {"ast.TypeDefinition", true},
		"TypeExtension":               {"ast.TypeExtension", true},
		"TypeSystemDefinition":        {"ast.TypeSystemDefinition", true},
		"TypeSystemExtension":         {"ast.TypeSystemExtension", true},
		"UnionMemberTypes":            {"ast.Types", true},
		"UnionTypeExtension":          {"ast.TypeExtension", true},
		"VariableDefinitions":         {"ast.VariableDefinitions", true},
		"Argument":                    {"ast.Argument", false},
		"Definition":                  {"ast.Definition", false},
		"Description":                 {"string", false},
		"Directive":                   {"ast.Directive", false},
		"Document":                    {"ast.Document", false},
		"EnumValueDefinition":         {"ast.EnumValueDefinition", false},
		"FieldDefinition":             {"ast.FieldDefinition", false},
		"FieldSelection":              {"ast.Selection", false},
		"FragmentSpread":              {"ast.Selection", false},
		"InlineFragment":              {"ast.Selection", false},
		"InputValueDefinition":        {"ast.InputValueDefinition", false},
		"OperationTypeDefinition":     {"ast.OperationTypeDefinition", false},
		"RootOperationTypeDefinition": {"ast.RootOperationTypeDefinition", false},
		"Selection":                   {"ast.Selection", false},
		"Type":                        {"ast.Type", false},
		"Value":                       {"ast.Value", false},
		"VariableDefinition":          {"ast.VariableDefinition", false},
	}
)

var header = `
// Code generated by lab/walkergen
// DO NOT EDIT!
`

var imports = `
import "github.com/bucketd/go-graphqlparser/ast"
`

var walkerHead = `
// Walker holds event handlers for entering and leaving AST nodes.
type Walker struct {
`

var walkerBottom = `
}

// NewWalker returns a new Walker instance.
func NewWalker(rules []RuleFunc) *Walker {
	walker := &Walker{}
	for _, rule := range rules {
		rule(walker)
	}

	return walker
}
`

func main() {
	flag.StringVar(&packageName, "package", "", "The package name to use in the generated code.")
	flag.Parse()

	tns := make([]string, 0, len(ti))
	for tn := range ti {
		tns = append(tns, tn)
	}
	sort.Strings(tns)

	// Header and package name
	fmt.Fprintf(os.Stdout, strings.TrimSpace(header))
	fmt.Fprintf(os.Stdout, "\npackage %s\n", packageName)
	fmt.Fprintf(os.Stdout, "%s\n", imports)

	// Walker head
	fmt.Fprintf(os.Stdout, walkerHead+"\t")

	// Walker middle
	for i, tn := range tns {
		err := handlers.Execute(os.Stdout, map[string]string{
			"TypeNameLCF": lcfirst(tn),
			"TypeName":    tn,
		})

		if err != nil {
			log.Fatal(err)
		}

		if i < len(tns) {
			fmt.Fprintf(os.Stdout, "\n\t")
		}
	}

	// Walker bottom
	fmt.Fprintf(os.Stdout, walkerBottom)

	// Event handlers
	for _, tn := range tns {
		err := eventHandlers.Execute(os.Stdout, map[string]string{
			"TypeNameLCF":  lcfirst(tn),
			"TypeName":     tn,
			"RealTypeName": realTypeName(tn),
			"AbridgedTN":   sane(strings.Map(abridger, tn)),
			"Pointer":      ptrIf(ti[tn].isPointer),
		})

		if err != nil {
			log.Fatal(err)
		}
	}
}

var handlers = template.Must(template.New("handlers").Parse(strings.TrimSpace(`
	{{.TypeNameLCF}}EventHandlers {{.TypeName}}EventHandlers
`)))

var eventHandlers = template.Must(template.New("eventHandlers").Parse(`
// {{.TypeName}}EventHandler function can handle enter/leave events for {{.TypeName}}.
type {{.TypeName}}EventHandler func(*Context, {{.Pointer}}{{.RealTypeName}})

// {{.TypeName}}EventHandlers stores the enter and leave events handlers.
type {{.TypeName}}EventHandlers struct {
	enter []{{.TypeName}}EventHandler
	leave []{{.TypeName}}EventHandler
}

// Add{{.TypeName}}EnterEventHandler adds an event handler to be called when entering a {{.TypeName}} node.
func (w *Walker) Add{{.TypeName}}EnterEventHandler(handler {{.TypeName}}EventHandler) {
	w.{{.TypeNameLCF}}EventHandlers.enter = append(w.{{.TypeNameLCF}}EventHandlers.enter, handler)
}

// Add{{.TypeName}}LeaveEventHandler adds an event handler to be called when leaving a {{.TypeName}} node.
func (w *Walker) Add{{.TypeName}}LeaveEventHandler(handler {{.TypeName}}EventHandler) {
	w.{{.TypeNameLCF}}EventHandlers.leave = append(w.{{.TypeNameLCF}}EventHandlers.leave, handler)
}

// On{{.TypeName}}Enter calls the enter event handlers registered for this node type.
func (w *Walker) On{{.TypeName}}Enter(ctx *Context, {{.AbridgedTN}} {{.Pointer}}{{.RealTypeName}}) {
	for _, handler := range w.{{.TypeNameLCF}}EventHandlers.enter {
		handler(ctx, {{.AbridgedTN}})
	}
}

// On{{.TypeName}}Leave calls the leave event handlers registered for this node type.
func (w *Walker) On{{.TypeName}}Leave(ctx *Context, {{.AbridgedTN}} {{.Pointer}}{{.RealTypeName}}) {
	for _, handler := range w.{{.TypeNameLCF}}EventHandlers.leave {
		handler(ctx, {{.AbridgedTN}})
	}
}
`))

func lcfirst(in string) string {
	if len(in) == 0 {
		return in
	}

	if len(in) == 1 {
		return strings.ToLower(in)
	}

	fr, w := utf8.DecodeRuneInString(in)

	return strings.ToLower(string(fr)) + in[w:]
}

func abridger(r rune) rune {
	if unicode.IsUpper(r) {
		return unicode.ToLower(r)
	}
	return -1
}

func in(item string, list []string) bool {
	for _, thing := range list {
		if thing == item {
			return true
		}
	}
	return false
}

func ptrIf(isPtr bool) string {
	if isPtr {
		return "*"
	}
	return ""
}

func sane(typeName string) string {
	switch typeName {
	case "type":
		return "t"
	case "error":
		return "err"
	case "if":
		return "ilf"
	}
	return typeName
}

func realTypeName(tn string) string {
	if typeInfo := ti[tn]; len(typeInfo.realTypeName) > 0 {
		return typeInfo.realTypeName
	}
	return tn
}
