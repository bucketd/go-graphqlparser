// Code generated by lab/generics
// DO NOT EDIT!
package ast

// Arguments is a linked list that contains Argument values.
type Arguments struct {
	Data Argument
	next *Arguments
	pos  int
}

// Add appends a Argument to this linked list and returns this new head.
func (a *Arguments) Add(data Argument) *Arguments {
	var pos int

	if a != nil {
		pos = a.pos + 1
	}

	return &Arguments{
		Data: data,
		next: a,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (a *Arguments) ForEach(fn func(argument Argument, i int)) {
	if a == nil {
		return
	}

	iter := 0
	current := a

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the Argument in the position given.
func (a *Arguments) Insert(item Argument, pos int) {}

// Join attaches the tail of the receiver list "a" to the head of the otherList.
func (a *Arguments) Join(otherList *Arguments) {
	pos := a.Len() + otherList.Len() - 1

	last := a
	for a != nil {
		a.pos = pos
		pos--
		last = a
		a = a.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (a *Arguments) Len() int {
	if a == nil {
		return 0
	}
	return a.pos + 1
}

// Reverse reverses this linked list of Argument. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (a *Arguments) Reverse() *Arguments {
	current := a

	var prev *Arguments
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// ArgumentsFromSlice returns a Arguments list from a slice of Argument.
func ArgumentsFromSlice(sl []Argument) *Arguments {
	var list *Arguments
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// Definitions is a linked list that contains Definition values.
type Definitions struct {
	Data Definition
	next *Definitions
	pos  int
}

// Add appends a Definition to this linked list and returns this new head.
func (d *Definitions) Add(data Definition) *Definitions {
	var pos int

	if d != nil {
		pos = d.pos + 1
	}

	return &Definitions{
		Data: data,
		next: d,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (d *Definitions) ForEach(fn func(definition Definition, i int)) {
	if d == nil {
		return
	}

	iter := 0
	current := d

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the Definition in the position given.
func (d *Definitions) Insert(item Definition, pos int) {}

// Join attaches the tail of the receiver list "d" to the head of the otherList.
func (d *Definitions) Join(otherList *Definitions) {
	pos := d.Len() + otherList.Len() - 1

	last := d
	for d != nil {
		d.pos = pos
		pos--
		last = d
		d = d.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (d *Definitions) Len() int {
	if d == nil {
		return 0
	}
	return d.pos + 1
}

// Reverse reverses this linked list of Definition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (d *Definitions) Reverse() *Definitions {
	current := d

	var prev *Definitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// DefinitionsFromSlice returns a Definitions list from a slice of Definition.
func DefinitionsFromSlice(sl []Definition) *Definitions {
	var list *Definitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// Directives is a linked list that contains Directive values.
type Directives struct {
	Data Directive
	next *Directives
	pos  int
}

// Add appends a Directive to this linked list and returns this new head.
func (d *Directives) Add(data Directive) *Directives {
	var pos int

	if d != nil {
		pos = d.pos + 1
	}

	return &Directives{
		Data: data,
		next: d,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (d *Directives) ForEach(fn func(directive Directive, i int)) {
	if d == nil {
		return
	}

	iter := 0
	current := d

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the Directive in the position given.
func (d *Directives) Insert(item Directive, pos int) {}

// Join attaches the tail of the receiver list "d" to the head of the otherList.
func (d *Directives) Join(otherList *Directives) {
	pos := d.Len() + otherList.Len() - 1

	last := d
	for d != nil {
		d.pos = pos
		pos--
		last = d
		d = d.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (d *Directives) Len() int {
	if d == nil {
		return 0
	}
	return d.pos + 1
}

// Reverse reverses this linked list of Directive. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (d *Directives) Reverse() *Directives {
	current := d

	var prev *Directives
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// DirectivesFromSlice returns a Directives list from a slice of Directive.
func DirectivesFromSlice(sl []Directive) *Directives {
	var list *Directives
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// DirectiveLocations is a linked list that contains DirectiveLocation values.
type DirectiveLocations struct {
	Data DirectiveLocation
	next *DirectiveLocations
	pos  int
}

// Add appends a DirectiveLocation to this linked list and returns this new head.
func (dl *DirectiveLocations) Add(data DirectiveLocation) *DirectiveLocations {
	var pos int

	if dl != nil {
		pos = dl.pos + 1
	}

	return &DirectiveLocations{
		Data: data,
		next: dl,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (dl *DirectiveLocations) ForEach(fn func(directiveLocation DirectiveLocation, i int)) {
	if dl == nil {
		return
	}

	iter := 0
	current := dl

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the DirectiveLocation in the position given.
func (dl *DirectiveLocations) Insert(item DirectiveLocation, pos int) {}

// Join attaches the tail of the receiver list "dl" to the head of the otherList.
func (dl *DirectiveLocations) Join(otherList *DirectiveLocations) {
	pos := dl.Len() + otherList.Len() - 1

	last := dl
	for dl != nil {
		dl.pos = pos
		pos--
		last = dl
		dl = dl.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (dl *DirectiveLocations) Len() int {
	if dl == nil {
		return 0
	}
	return dl.pos + 1
}

// Reverse reverses this linked list of DirectiveLocation. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (dl *DirectiveLocations) Reverse() *DirectiveLocations {
	current := dl

	var prev *DirectiveLocations
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// DirectiveLocationsFromSlice returns a DirectiveLocations list from a slice of DirectiveLocation.
func DirectiveLocationsFromSlice(sl []DirectiveLocation) *DirectiveLocations {
	var list *DirectiveLocations
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// EnumValueDefinitions is a linked list that contains EnumValueDefinition values.
type EnumValueDefinitions struct {
	Data EnumValueDefinition
	next *EnumValueDefinitions
	pos  int
}

// Add appends a EnumValueDefinition to this linked list and returns this new head.
func (evd *EnumValueDefinitions) Add(data EnumValueDefinition) *EnumValueDefinitions {
	var pos int

	if evd != nil {
		pos = evd.pos + 1
	}

	return &EnumValueDefinitions{
		Data: data,
		next: evd,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (evd *EnumValueDefinitions) ForEach(fn func(enumValueDefinition EnumValueDefinition, i int)) {
	if evd == nil {
		return
	}

	iter := 0
	current := evd

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the EnumValueDefinition in the position given.
func (evd *EnumValueDefinitions) Insert(item EnumValueDefinition, pos int) {}

// Join attaches the tail of the receiver list "evd" to the head of the otherList.
func (evd *EnumValueDefinitions) Join(otherList *EnumValueDefinitions) {
	pos := evd.Len() + otherList.Len() - 1

	last := evd
	for evd != nil {
		evd.pos = pos
		pos--
		last = evd
		evd = evd.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (evd *EnumValueDefinitions) Len() int {
	if evd == nil {
		return 0
	}
	return evd.pos + 1
}

// Reverse reverses this linked list of EnumValueDefinition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (evd *EnumValueDefinitions) Reverse() *EnumValueDefinitions {
	current := evd

	var prev *EnumValueDefinitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// EnumValueDefinitionsFromSlice returns a EnumValueDefinitions list from a slice of EnumValueDefinition.
func EnumValueDefinitionsFromSlice(sl []EnumValueDefinition) *EnumValueDefinitions {
	var list *EnumValueDefinitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// FieldDefinitions is a linked list that contains FieldDefinition values.
type FieldDefinitions struct {
	Data FieldDefinition
	next *FieldDefinitions
	pos  int
}

// Add appends a FieldDefinition to this linked list and returns this new head.
func (fd *FieldDefinitions) Add(data FieldDefinition) *FieldDefinitions {
	var pos int

	if fd != nil {
		pos = fd.pos + 1
	}

	return &FieldDefinitions{
		Data: data,
		next: fd,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (fd *FieldDefinitions) ForEach(fn func(fieldDefinition FieldDefinition, i int)) {
	if fd == nil {
		return
	}

	iter := 0
	current := fd

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the FieldDefinition in the position given.
func (fd *FieldDefinitions) Insert(item FieldDefinition, pos int) {}

// Join attaches the tail of the receiver list "fd" to the head of the otherList.
func (fd *FieldDefinitions) Join(otherList *FieldDefinitions) {
	pos := fd.Len() + otherList.Len() - 1

	last := fd
	for fd != nil {
		fd.pos = pos
		pos--
		last = fd
		fd = fd.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (fd *FieldDefinitions) Len() int {
	if fd == nil {
		return 0
	}
	return fd.pos + 1
}

// Reverse reverses this linked list of FieldDefinition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (fd *FieldDefinitions) Reverse() *FieldDefinitions {
	current := fd

	var prev *FieldDefinitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// FieldDefinitionsFromSlice returns a FieldDefinitions list from a slice of FieldDefinition.
func FieldDefinitionsFromSlice(sl []FieldDefinition) *FieldDefinitions {
	var list *FieldDefinitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// InputValueDefinitions is a linked list that contains InputValueDefinition values.
type InputValueDefinitions struct {
	Data InputValueDefinition
	next *InputValueDefinitions
	pos  int
}

// Add appends a InputValueDefinition to this linked list and returns this new head.
func (ivd *InputValueDefinitions) Add(data InputValueDefinition) *InputValueDefinitions {
	var pos int

	if ivd != nil {
		pos = ivd.pos + 1
	}

	return &InputValueDefinitions{
		Data: data,
		next: ivd,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (ivd *InputValueDefinitions) ForEach(fn func(inputValueDefinition InputValueDefinition, i int)) {
	if ivd == nil {
		return
	}

	iter := 0
	current := ivd

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the InputValueDefinition in the position given.
func (ivd *InputValueDefinitions) Insert(item InputValueDefinition, pos int) {}

// Join attaches the tail of the receiver list "ivd" to the head of the otherList.
func (ivd *InputValueDefinitions) Join(otherList *InputValueDefinitions) {
	pos := ivd.Len() + otherList.Len() - 1

	last := ivd
	for ivd != nil {
		ivd.pos = pos
		pos--
		last = ivd
		ivd = ivd.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (ivd *InputValueDefinitions) Len() int {
	if ivd == nil {
		return 0
	}
	return ivd.pos + 1
}

// Reverse reverses this linked list of InputValueDefinition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (ivd *InputValueDefinitions) Reverse() *InputValueDefinitions {
	current := ivd

	var prev *InputValueDefinitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// InputValueDefinitionsFromSlice returns a InputValueDefinitions list from a slice of InputValueDefinition.
func InputValueDefinitionsFromSlice(sl []InputValueDefinition) *InputValueDefinitions {
	var list *InputValueDefinitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// OperationTypeDefinitions is a linked list that contains OperationTypeDefinition values.
type OperationTypeDefinitions struct {
	Data OperationTypeDefinition
	next *OperationTypeDefinitions
	pos  int
}

// Add appends a OperationTypeDefinition to this linked list and returns this new head.
func (otd *OperationTypeDefinitions) Add(data OperationTypeDefinition) *OperationTypeDefinitions {
	var pos int

	if otd != nil {
		pos = otd.pos + 1
	}

	return &OperationTypeDefinitions{
		Data: data,
		next: otd,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (otd *OperationTypeDefinitions) ForEach(fn func(operationTypeDefinition OperationTypeDefinition, i int)) {
	if otd == nil {
		return
	}

	iter := 0
	current := otd

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the OperationTypeDefinition in the position given.
func (otd *OperationTypeDefinitions) Insert(item OperationTypeDefinition, pos int) {}

// Join attaches the tail of the receiver list "otd" to the head of the otherList.
func (otd *OperationTypeDefinitions) Join(otherList *OperationTypeDefinitions) {
	pos := otd.Len() + otherList.Len() - 1

	last := otd
	for otd != nil {
		otd.pos = pos
		pos--
		last = otd
		otd = otd.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (otd *OperationTypeDefinitions) Len() int {
	if otd == nil {
		return 0
	}
	return otd.pos + 1
}

// Reverse reverses this linked list of OperationTypeDefinition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (otd *OperationTypeDefinitions) Reverse() *OperationTypeDefinitions {
	current := otd

	var prev *OperationTypeDefinitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// OperationTypeDefinitionsFromSlice returns a OperationTypeDefinitions list from a slice of OperationTypeDefinition.
func OperationTypeDefinitionsFromSlice(sl []OperationTypeDefinition) *OperationTypeDefinitions {
	var list *OperationTypeDefinitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// RootOperationTypeDefinitions is a linked list that contains RootOperationTypeDefinition values.
type RootOperationTypeDefinitions struct {
	Data RootOperationTypeDefinition
	next *RootOperationTypeDefinitions
	pos  int
}

// Add appends a RootOperationTypeDefinition to this linked list and returns this new head.
func (rotd *RootOperationTypeDefinitions) Add(data RootOperationTypeDefinition) *RootOperationTypeDefinitions {
	var pos int

	if rotd != nil {
		pos = rotd.pos + 1
	}

	return &RootOperationTypeDefinitions{
		Data: data,
		next: rotd,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (rotd *RootOperationTypeDefinitions) ForEach(fn func(rootOperationTypeDefinition RootOperationTypeDefinition, i int)) {
	if rotd == nil {
		return
	}

	iter := 0
	current := rotd

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the RootOperationTypeDefinition in the position given.
func (rotd *RootOperationTypeDefinitions) Insert(item RootOperationTypeDefinition, pos int) {}

// Join attaches the tail of the receiver list "rotd" to the head of the otherList.
func (rotd *RootOperationTypeDefinitions) Join(otherList *RootOperationTypeDefinitions) {
	pos := rotd.Len() + otherList.Len() - 1

	last := rotd
	for rotd != nil {
		rotd.pos = pos
		pos--
		last = rotd
		rotd = rotd.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (rotd *RootOperationTypeDefinitions) Len() int {
	if rotd == nil {
		return 0
	}
	return rotd.pos + 1
}

// Reverse reverses this linked list of RootOperationTypeDefinition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (rotd *RootOperationTypeDefinitions) Reverse() *RootOperationTypeDefinitions {
	current := rotd

	var prev *RootOperationTypeDefinitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// RootOperationTypeDefinitionsFromSlice returns a RootOperationTypeDefinitions list from a slice of RootOperationTypeDefinition.
func RootOperationTypeDefinitionsFromSlice(sl []RootOperationTypeDefinition) *RootOperationTypeDefinitions {
	var list *RootOperationTypeDefinitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// Selections is a linked list that contains Selection values.
type Selections struct {
	Data Selection
	next *Selections
	pos  int
}

// Add appends a Selection to this linked list and returns this new head.
func (s *Selections) Add(data Selection) *Selections {
	var pos int

	if s != nil {
		pos = s.pos + 1
	}

	return &Selections{
		Data: data,
		next: s,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (s *Selections) ForEach(fn func(selection Selection, i int)) {
	if s == nil {
		return
	}

	iter := 0
	current := s

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the Selection in the position given.
func (s *Selections) Insert(item Selection, pos int) {}

// Join attaches the tail of the receiver list "s" to the head of the otherList.
func (s *Selections) Join(otherList *Selections) {
	pos := s.Len() + otherList.Len() - 1

	last := s
	for s != nil {
		s.pos = pos
		pos--
		last = s
		s = s.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (s *Selections) Len() int {
	if s == nil {
		return 0
	}
	return s.pos + 1
}

// Reverse reverses this linked list of Selection. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (s *Selections) Reverse() *Selections {
	current := s

	var prev *Selections
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// SelectionsFromSlice returns a Selections list from a slice of Selection.
func SelectionsFromSlice(sl []Selection) *Selections {
	var list *Selections
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// Types is a linked list that contains Type values.
type Types struct {
	Data Type
	next *Types
	pos  int
}

// Add appends a Type to this linked list and returns this new head.
func (t *Types) Add(data Type) *Types {
	var pos int

	if t != nil {
		pos = t.pos + 1
	}

	return &Types{
		Data: data,
		next: t,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (t *Types) ForEach(fn func(t Type, i int)) {
	if t == nil {
		return
	}

	iter := 0
	current := t

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the Type in the position given.
func (t *Types) Insert(item Type, pos int) {}

// Join attaches the tail of the receiver list "t" to the head of the otherList.
func (t *Types) Join(otherList *Types) {
	pos := t.Len() + otherList.Len() - 1

	last := t
	for t != nil {
		t.pos = pos
		pos--
		last = t
		t = t.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (t *Types) Len() int {
	if t == nil {
		return 0
	}
	return t.pos + 1
}

// Reverse reverses this linked list of Type. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (t *Types) Reverse() *Types {
	current := t

	var prev *Types
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// TypesFromSlice returns a Types list from a slice of Type.
func TypesFromSlice(sl []Type) *Types {
	var list *Types
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}

// VariableDefinitions is a linked list that contains VariableDefinition values.
type VariableDefinitions struct {
	Data VariableDefinition
	next *VariableDefinitions
	pos  int
}

// Add appends a VariableDefinition to this linked list and returns this new head.
func (vd *VariableDefinitions) Add(data VariableDefinition) *VariableDefinitions {
	var pos int

	if vd != nil {
		pos = vd.pos + 1
	}

	return &VariableDefinitions{
		Data: data,
		next: vd,
		pos:  pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func (vd *VariableDefinitions) ForEach(fn func(variableDefinition VariableDefinition, i int)) {
	if vd == nil {
		return
	}

	iter := 0
	current := vd

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the VariableDefinition in the position given.
func (vd *VariableDefinitions) Insert(item VariableDefinition, pos int) {}

// Join attaches the tail of the receiver list "vd" to the head of the otherList.
func (vd *VariableDefinitions) Join(otherList *VariableDefinitions) {
	pos := vd.Len() + otherList.Len() - 1

	last := vd
	for vd != nil {
		vd.pos = pos
		pos--
		last = vd
		vd = vd.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func (vd *VariableDefinitions) Len() int {
	if vd == nil {
		return 0
	}
	return vd.pos + 1
}

// Reverse reverses this linked list of VariableDefinition. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func (vd *VariableDefinitions) Reverse() *VariableDefinitions {
	current := vd

	var prev *VariableDefinitions
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// VariableDefinitionsFromSlice returns a VariableDefinitions list from a slice of VariableDefinition.
func VariableDefinitionsFromSlice(sl []VariableDefinition) *VariableDefinitions {
	var list *VariableDefinitions
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}
