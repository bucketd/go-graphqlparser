package walker

import (
	"strings"
	"text/template"
	"unicode"

	"github.com/Masterminds/sprig"
	"github.com/bucketd/go-graphqlparser/tools/walkergen/goast"
)

// header is a comment placed at the top of the file to signal to other Go tools, and users to not
// alter this file, as changes may be overwritten anyway.
var header = `
// Code generated by lab/walkergen
// DO NOT EDIT!
`

// imports specifies the list of imports for when we generate a walker outside of our ast package.
var imports = `
import "github.com/bucketd/go-graphqlparser/ast"
`

// walkerTypeTmpl is the template used to generate the type declaration, and constructor for the
// Walker type, populating it with event handlers as fields.
var walkerTypeTmpl = template.Must(template.New("walkerTypeTmpl").Funcs(sprig.TxtFuncMap()).Parse(`
// Walker holds event handlers for entering and leaving AST nodes.
type Walker struct { {{- range .}}
	{{untitle .TypeName}}EventHandlers {{.TypeName}}EventHandlers{{end}}
}

// NewWalker returns a new Walker instance.
func NewWalker(rules []RuleFunc) *Walker {
	walker := &Walker{}
	for _, rule := range rules {
		rule(walker)
	}

	return walker
}
`))

// eventHandlersTmpl is the template used to generate the event handler functions for the walker,
// and the corresponding types that have the event handler functions attached.
var eventHandlersTmpl = template.Must(template.New("eventHandlersTmpl").Funcs(sprig.TxtFuncMap()).Parse(`
// {{.TypeName}}EventHandler function can handle enter/leave events for {{.TypeName}}.
type {{.TypeName}}EventHandler func(*Context, {{if .IsPointer}}*{{end}}ast.{{.TypeName}})

// {{.TypeName}}EventHandlers stores the enter and leave events handlers.
type {{.TypeName}}EventHandlers struct {
	enter []{{.TypeName}}EventHandler
	leave []{{.TypeName}}EventHandler
}

// Add{{.TypeName}}EnterEventHandler adds an event handler to be called when entering {{.TypeName}} nodes.
func (w *Walker) Add{{.TypeName}}EnterEventHandler(h {{.TypeName}}EventHandler) {
	w.{{untitle .TypeName}}EventHandlers.enter = append(w.{{untitle .TypeName}}EventHandlers.enter, h)
}

// Add{{.TypeName}}LeaveEventHandler adds an event handler to be called when leaving {{.TypeName}} nodes.
func (w *Walker) Add{{.TypeName}}LeaveEventHandler(h {{.TypeName}}EventHandler) {
	w.{{untitle .TypeName}}EventHandlers.leave = append(w.{{untitle .TypeName}}EventHandlers.leave, h)
}

// On{{.TypeName}}Enter calls the enter event handlers registered for this node type.
func (w *Walker) On{{.TypeName}}Enter(ctx *Context, {{.ShortTypeName}} {{if .IsPointer}}*{{end}}ast.{{.TypeName}}) {
	for _, handler := range w.{{untitle .TypeName}}EventHandlers.enter {
		handler(ctx, {{.ShortTypeName}})
	}
}

// On{{.TypeName}}Leave calls the leave event handlers registered for this node type.
func (w *Walker) On{{.TypeName}}Leave(ctx *Context, {{.ShortTypeName}} {{if .IsPointer}}*{{end}}ast.{{.TypeName}}) {
	for _, handler := range w.{{untitle .TypeName}}EventHandlers.leave {
		handler(ctx, {{.ShortTypeName}})
	}
}
`))

// walkFnTmpl is the template for generating a walker function.
var walkFnTmpl = template.Must(template.New("walkFnTmpl").Funcs(sprig.TxtFuncMap()).Parse(`
// walk{{.TypeName}} ...
func (w *Walker) walk{{.TypeName}}(ctx *Context, {{.ShortTypeName}} {{if .IsArray}}[]{{end}}{{if .IsPointer}}*{{end}}ast.{{.TypeName}}) {
	w.On{{.TypeName}}Enter(ctx, {{.ShortTypeName}})
	{{if .IsListType}}{{.ShortTypeName}}.ForEach(func({{.NodeType.ShortTypeName}} ast.{{.NodeType.TypeName}}, i int) {
		w.walk{{.NodeType.TypeName}}(ctx, {{.NodeType.ShortTypeName}})
	})
	{{else if .Consts}}switch {{.ShortTypeName}}.Kind {
	{{range .Consts}}case ast.{{.Name}}:
		{{if ne .Field "self"}}w.walk{{.Field}}(ctx, {{$.ShortTypeName}}.{{.Field}}){{else}}w.walk{{.SelfName}}(ctx, {{$.ShortTypeName}}){{end}}
	{{end}}}
	{{end}}w.On{{.TypeName}}Leave(ctx, {{.ShortTypeName}})
}
`))

// templateData contains data and methods necessary for populating walker templates.
type templateData struct {
	goast.Type
	// Consts contains the constants related to this type.
	Consts goast.Consts
	// NodeType is populated if this type is a list type (i.e. IsListType = true).
	NodeType *templateData
	// IsListType is true if this type is a linked list type.
	IsListType bool
	// IsSwitcher is a type that we need to generate a switch statement for.
	IsSwitcher bool
}

// ShortTypeName returns an abridged version of the embedded type's name.
func (ttd templateData) ShortTypeName() string {
	stn := strings.Map(abridger, ttd.TypeName)
	if ttd.IsListType {
		return stn + "s"
	}

	return stn
}

// abridger is a strings.Map function that is used to return a variable name from a type name that
// makes sense by taking each capital letter from the given string and converting them to lowercase.
// The input string should start with a capital letter.
func abridger(r rune) rune {
	if unicode.IsUpper(r) {
		return unicode.ToLower(r)
	}
	return -1
}
