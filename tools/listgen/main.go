package main

import (
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

var (
	packageName string
	typeNames   string
)

var header = `
// Code generated by tools/listgen
// DO NOT EDIT!
`

func main() {
	flag.StringVar(&packageName, "package", "", "The package name to use in the generated code.")
	flag.StringVar(&typeNames, "types", "", "Comma separated names of types to generate.")
	flag.Parse()

	fmt.Fprintf(os.Stdout, strings.TrimSpace(header))
	fmt.Fprintf(os.Stdout, "\npackage %s\n", packageName)

	tns := strings.Split(typeNames, ",")

	sort.Strings(tns)

	for _, tn := range tns {
		typeNameLCF := lcfirst(tn)
		if typeNameLCF == "type" {
			typeNameLCF = "t"
		}
		if typeNameLCF == "error" {
			typeNameLCF = "err"
		}

		abridged := strings.Map(abridger, tn)
		if abridged == "" {
			r, _ := utf8.DecodeRuneInString(tn)
			abridged = strings.ToLower(string(r))
		}

		linkedList.Execute(os.Stdout, map[string]string{
			"TypeNameLCF": typeNameLCF,
			"TypeName":    tn,
			"AbridgedTN":  abridged,
		})
	}
}

var linkedList = template.Must(template.New("linkedList").Parse(`
// {{.TypeName}}s is a linked list that contains {{.TypeName}} values.
type {{.TypeName}}s struct {
	Data {{.TypeName}}
	next *{{.TypeName}}s
	pos  int
}

// Add appends a {{.TypeName}} to this linked list and returns this new head.
func ({{.AbridgedTN}}s *{{.TypeName}}s) Add(data {{.TypeName}}) *{{.TypeName}}s {
	var pos int

	if {{.AbridgedTN}}s != nil {
		pos = {{.AbridgedTN}}s.pos + 1
	}

	return &{{.TypeName}}s{
		Data: data,
		next: {{.AbridgedTN}}s,
		pos: pos,
	}
}

// ForEach applies the given map function to each item in this linked list.
func ({{.AbridgedTN}}s *{{.TypeName}}s) ForEach(fn func({{.AbridgedTN}} {{.TypeName}}, i int)) {
	if {{.AbridgedTN}}s == nil {
		return
	}

	iter := 0
	current := {{.AbridgedTN}}s

	for {
		fn(current.Data, iter)

		if current.next == nil {
			break
		}

		iter++
		current = current.next
	}
}

// Insert places the {{.TypeName}} in the position given by pos.
// The method will insert at top if pos is greater than or equal to list length.
// The method will insert at bottom if the pos is less than 0.
func ({{.AbridgedTN}}s *{{.TypeName}}s) Insert({{.AbridgedTN}} {{.TypeName}}, pos int) *{{.TypeName}}s {
	if pos >= {{.AbridgedTN}}s.Len() || {{.AbridgedTN}}s == nil {
		return {{.AbridgedTN}}s.Add({{.AbridgedTN}})
	}

	if pos < 0 {
		pos = 0
	}

	mid := {{.AbridgedTN}}s
	for mid.pos != pos {
		mid = mid.next
	}

	bot := mid.next
	mid.next = nil
	{{.AbridgedTN}}s.pos -= mid.pos

	bot = bot.Add({{.AbridgedTN}})
	{{.AbridgedTN}}s.Join(bot)

	return {{.AbridgedTN}}s
}

// Join attaches the tail of the receiver list "{{.AbridgedTN}}s" to the head of the otherList.
func ({{.AbridgedTN}}s *{{.TypeName}}s) Join(otherList *{{.TypeName}}s) {
	if {{.AbridgedTN}}s == nil {
		return
	}
	
	pos := {{.AbridgedTN}}s.Len() + otherList.Len() - 1

	last := {{.AbridgedTN}}s
	for {{.AbridgedTN}}s != nil {
		{{.AbridgedTN}}s.pos = pos
		pos--
		last = {{.AbridgedTN}}s
		{{.AbridgedTN}}s = {{.AbridgedTN}}s.next
	}

	last.next = otherList
}

// Len returns the length of this linked list.
func ({{.AbridgedTN}}s *{{.TypeName}}s) Len() int {
	if {{.AbridgedTN}}s == nil {
		return 0
	}
	return {{.AbridgedTN}}s.pos + 1
}

// Reverse reverses this linked list of {{.TypeName}}. Usually when the linked list is being
// constructed the result will be last-to-first, so we'll want to reverse it to get it in the
// "right" order.
func ({{.AbridgedTN}}s *{{.TypeName}}s) Reverse() *{{.TypeName}}s {
	current := {{.AbridgedTN}}s

	var prev *{{.TypeName}}s
	var pos int

	for current != nil {
		current.pos = pos
		pos++

		next := current.next
		current.next = prev
		prev = current
		current = next
	}

	return prev
}

// {{.TypeName}}sFromSlice returns a {{.TypeName}}s list from a slice of {{.TypeName}}.
func {{.TypeName}}sFromSlice(sl []{{.TypeName}}) *{{.TypeName}}s {
	var list *{{.TypeName}}s
	for _, v := range sl {
		list = list.Add(v)
	}
	return list.Reverse()
}
`))

func lcfirst(in string) string {
	if len(in) == 0 {
		return in
	}

	if len(in) == 1 {
		return strings.ToLower(in)
	}

	fr, w := utf8.DecodeRuneInString(in)

	return strings.ToLower(string(fr)) + in[w:]
}

func abridger(r rune) rune {
	if unicode.IsUpper(r) {
		return unicode.ToLower(r)
	}
	return -1
}
